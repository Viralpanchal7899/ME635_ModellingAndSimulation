function q_new = RRA(p_d,q,J_gen,X,Y,Z)

v_max = 0.5;
v_min = 0.1; 
lambda_p = 5;
delta_t = 1;
p_c = [subs(X);subs(Y);subs(Z)]
position_eps = 2.4;
position_err = (sqrt((p_d - p_c)'*(p_d-p_c)));
% % Computing Jacobian
% J = subs(J_gen);
% J_inv = pinv(J);
% q_old = q; 
iter = 0;


while position_err > position_eps
    % Computing Jacobian
    J = subs(J_gen);
    J_inv = pinv(J);
    % for desired position velocity p_d_dot = ||v||*n_hat
    n_hat = ((p_d-p_c)./(p_d-p_c));
    if (position_err/position_eps)<=lambda_p
        v_tilde = v_min + (((v_max-v_min)*(position_err-position_eps))/(position_eps*(lambda_p-1)));
    else
        v_tilde = v_max;
    end
    p_d_dot = v_tilde * n_hat;
    q_d_dot = J_inv*p_d_dot;
    q = q + q_d_dot*delta_t;
    
    q1 = feval('round',q(1,1),2);
    q2 = feval('round',q(2,1),2);
    q3 = feval('round',q(3,1),2);
    q4 = feval('round',q(4,1),2);
    q5 = feval('round',q(5,1),2);
    
    % getting the new coordinates
    p_c = feval[subs(X);subs(Y);subs(Z)]
    
    % recomputing the position error
    position_err = feval('round',(sqrt((p_d - p_c)'*(p_d-p_c))),2)    
    
    iter = iter + 1
end

disp(q)
q1 = feval('round',q(1,1),2);
q2 = feval('round',q(2,1),2);
q3 = feval('round',q(3,1),2);
q4 = feval('round',q(4,1),2);
q5 = feval('round',q(5,1),2);

X_new = feval('round',subs(X),2)
Y_new = feval('round',subs(Y),2)
Z_new = feval('round',subs(Z),2)
fprintf('done')
end
